<!--
  In this example we push our data into a queue
  which we can step through inside the editor with the arrows keys (←, →)
-->
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
</head>
<body>

<div id="container" style="width:640px; height:480px"></div>

<h3>Use <button onclick="back()">←</button> <button onclick="next()">→</button> to step through the code</h3>

<script>
let code = `
function add(a, b) {
  return a + b;
};

function main() {
  let res = 0;
  let ii = 0;
  for (let ii = 0; ii < 3; ii++) {
    res += add(ii, 2);
  };
  return res;
};

main();
`;
</script>

<script type="text/javascript" src="../../dist/iroh-browser.js"></script>
<script src="monaco-editor/min/vs/loader.js"></script>
<script>
  let editor = null;
  let overlay = null;
  require.config({ paths: { 'vs': 'monaco-editor/min/vs' }});
  require(['vs/editor/editor.main'], function() {
    editor = monaco.editor.create(document.getElementById("container"), {
      value: "",
      language: "javascript",
      lineNumbers: true,
      roundedSelection: false,
      scrollBeyondLastLine: false,
      readOnly: false,
      theme: "vs-dark",
      minimap: {
        enabled: false
      },
      glyphMargin: true
    });
    editor.onDidChangeModelContent(event => {
      init(editor.getValue());
    });

    // Add an overlay widget
    overlay = {
      domNode: null,
      getId: function() {
        return 'my.overlay.widget';
      },
      getDomNode: function() {
        if (!this.domNode) {
          let node = document.createElement("div");
          this.domNode = node;
          node.innerHTML = "";
          node.style.background = 'rgba(0,0,0,0.15)';
        }
        return this.domNode;
      },
      getPosition: function() {
        return {
          position: {
            lineNumber: range.startLineNumber,
            column: range.startColumn
          },
          preference: [monaco.editor.ContentWidgetPositionPreference.ABOVE, monaco.editor.ContentWidgetPositionPreference.BELOW]
        };
      }
    };
    editor.setValue(code);
    editor.addContentWidget(overlay);
    init(code);
  });

  let stage = null;
  let range = null;
  let index = 0;
  let queue = [];
  let decorations = [];

  function init(input) {
    reset();
    stage = new Iroh.Stage(input);
    addListeners(stage);
    eval(stage.script);
    update();
  };

  function reset() {
    resetDecorations();
    stage = null;
    index = 0;
    queue = [];
    decorations = [];
  };

  window.addEventListener("keydown", (e) => {
    let key = e.keyCode;
    if (key === 39) next();
    else if (key === 37) back();
  });

  function next() {
    if (index < queue.length - 1) {
      index++;
      update();
    }
  };

  function back() {
    if (index > 0) {
      index--;
      update();
    }
  };

  function update() {
    resetDecorations();
    let event = queue[index];
    let loc = event.getLocation();
    range = new monaco.Range(
      loc.start.line, loc.start.column + 1,
      loc.end.line, loc.end.column + 1,
    );
    decorations = editor.deltaDecorations([], [
      { range: range, options: { inlineClassName: 'activeInline' }}
    ]);
    if (event.category === Iroh.PROGRAM && overlay.domNode) {
      overlay.domNode.innerHTML = "";
    }
    else if (overlay.domNode) {
      let value = (
        event.hasOwnProperty("value") ? event.value :
        event.hasOwnProperty("result") ? event.result :
        event.return || "unknown"
      );
      console.log(event);
      overlay.domNode.innerHTML = value;
    }
    editor.layoutContentWidget(overlay);
  };

  function resetDecorations() {
    editor.deltaDecorations(decorations, [{ range: new monaco.Range(0,0,999999,9999999999), options : { } }]);
  };

  function push(e) {
    queue.push(e);
  };

  function addListeners(stage) {

    // if
    stage.addListener(Iroh.IF)
    .on("enter", (e) => push(e))
    .on("leave", (e) => push(e));

    // else
    stage.addListener(Iroh.ELSE)
    .on("enter", (e) => push(e))
    .on("leave", (e) => push(e));

    // loop
    stage.addListener(Iroh.LOOP)
    .on("enter", (e) => push(e))
    .on("leave", (e) => push(e));

    // break
    stage.addListener(Iroh.BREAK)
    .on("fire", (e) => push(e));

    // continue
    stage.addListener(Iroh.CONTINUE)
    .on("fire", (e) => push(e));

    // switch
    stage.addListener(Iroh.SWITCH)
    .on("enter", (e) => push(e))
    .on("leave", (e) => push(e));

    // case, default
    stage.addListener(Iroh.CASE)
    .on("enter", (e) => push(e))
    .on("leave", (e) => push(e));

    // function call
    stage.addListener(Iroh.CALL)
    .on("before", (e) => push(e))
    .on("after", (e) => push(e));

    // function
    stage.addListener(Iroh.FUNCTION)
    .on("enter", (e) => push(e))
    .on("leave", (e) => push(e))
    .on("return", (e) => push(e));

    // variable
    stage.addListener(Iroh.VAR)
    .on("before", (e) => push(e))
    .on("after", (e) => push(e));

    // new
    stage.addListener(Iroh.OP_NEW)
    .on("before", (e) => push(e))
    .on("after", (e) => push(e));

    // try
    stage.addListener(Iroh.TRY)
    .on("before", (e) => push(e))
    .on("after", (e) => push(e));

    // allocation
    stage.addListener(Iroh.ALLOC)
    .on("fire", (e) => push(e));

    // member
    stage.addListener(Iroh.MEMBER)
    .on("fire", (e) => push(e));

    // this
    stage.addListener(Iroh.THIS)
    .on("fire", (e) => push(e));

    // assignment
    stage.addListener(Iroh.ASSIGN)
    .on("fire", (e) => push(e));

    // ternary
    stage.addListener(Iroh.TERNARY)
    .on("fire", (e) => push(e));

    // logical
    stage.addListener(Iroh.LOGICAL)
    .on("fire", (e) => push(e));

    // binary
    stage.addListener(Iroh.BINARY)
    .on("fire", (e) => push(e));

    // unary
    stage.addListener(Iroh.UNARY)
    .on("fire", (e) => push(e));

    // update
    stage.addListener(Iroh.UPDATE)
    .on("fire", (e) => push(e));

    // program
    stage.addListener(Iroh.PROGRAM)
    .on("enter", (e) => push(e))
    .on("leave", (e) => push(e));

  };
</script>
<style>
.activeInline {
  background: rgba(255,200,99,0.25);
}
</style>
</body>
</html>
